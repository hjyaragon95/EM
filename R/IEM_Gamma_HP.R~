
## TODO:
## (1) Finish E-step in SA-AA IEM
## (2) Write Q-function for AA-SA IEM

# Hierarchical Poisson model:

"gamma.hp.logLike" <- function(theta,y,method=1)
{
	alpha <- theta[1]
	m <- length(y$y)
	if (method == 1){
	  ll <- as.numeric(sum(lgamma(alpha+y$y)-lgamma(y$y+1)) - m*lgamma(alpha) - log(2)*sum(alpha+y$y))
	} else if (method == 2){
	  ll <- as.numeric(-sum(lgamma(y$y+1))-log(2)*sum(alpha+y$y))
	  for (i in 1:m){
	    if (y$y[i]>0){
	      ll <- ll + sum(log(alpha+y$y[i]-seq(1,y$y[i],by=1)))
	    }
	  }
	} else {
	  stop("'method' must be either 1 or 2")
	}
	return(ll)
}

"update.gamma.hp.sa.em" <- function(theta,y.obs,fixed,verbose){

	alpha.nr.t <- theta[1]
	alpha.t <- theta[1]
	max.nr.iter <- fixed$max.nr.iter
	y <- y.obs$y
	m <- y.obs$m
	
	## Implement NR-update:
	for (nr.iter in 1:max.nr.iter){
	
	  E.log.lambda <- digamma(alpha.t+y) - log(2)
	  alpha.nr.t1 <- alpha.nr.t - (digamma(alpha.nr.t) - mean(E.log.lambda))/psigamma(alpha.nr.t)
	  
	}
	
	if (alpha.nr.t1<eps){
	   alpha.nr.t1 <- eps
	}
	
	return(alpha.nr.t1)
}

"gamma.hp.sa.em" <- function(y,groups,theta.0,nr.tol=1e-4,em.tol=1e-6,em.tol.type="relative",nr.tol.type="relative",max.nr.iter=100,max.em.iter=1000,keep.paths=TRUE,print.every=1,verbose=TRUE)
{
	alpha.t  <- theta.0[1]
	
	u.levels <- unique(groups)
	J <- length(u.levels)
	n <- sum(y.group.sizes)
	m <- length(y)
	
	y.obs <- list("group.sums"=y.group.sums,"group.sizes"=y.group.sizes,"n"=n,"y"=y,"m"=m)
	fixed <- list("nr.tol"=nr.tol,"nr.tol.type"=nr.tol.type,"max.nr.iter"=max.nr.iter)

	if (verbose){
		cat("y.obs:\n") ; print(y.obs)
		cat("fixed:\n") ; print(fixed)
	}

	ret <- EM(y.obs=y.obs,theta.0=theta.0,fixed=fixed,update=update.gamma.hp.sa.em,logLike=gamma.hp.logLike,max.iter=max.em.iter,
		  tol=em.tol,tol.type=em.tol.type,keep.paths=keep.paths,print.every=print.every,verbose=verbose)

	return(ret)
}

"lambda.tilde.density" <- function(lambda.tilde,y,alpha,log=FALSE){
	    ## Must be vectorized wrt lambda.tilde argument:
	    Finv <- qgamma(p=lambda.tilde,alpha,1)
	    if (!log){
	      C.t <- gamma(alpha)*(2^(alpha+y))/gamma(alpha+y)
	      ret <- (Finv^y)*exp(-Finv)*C.t
	    } else {
	      ret <- (y+alpha)*log(2) + lgamma(alpha) - lgamma(alpha+y) + y*log(Finv) - Finv
	    }
	    return(ret)
}

## Must be defined externally for IEM

"update.gamma.hp.aa.em" <- function(theta,y.obs,fixed,verbose){

	alpha.t <- theta[1]
	alpha.start <- alpha.t
	lambda.tilde.nodes <- fixed$lambda.tilde.nodes
	lambda.tilde.weights <- fixed$lambda.tilde.weights
	eps <- fixed$eps
	y <- y.obs$y
	
	"Q.func.gamma.hp.AA" <- function(alpha,alpha.t,y,lambda.tilde.nodes,lambda.tilde.weights,verbose){
	
	    ## First, do the E-step using Gauss-Legendre Quadrature:
	    m <- length(y)
	    E.Finv <- rep(NA,m)
	    E.log.Finv <- rep(NA,m)
	    use.log <- TRUE
	    
	    for (i in 1:m){
	    
	      if (use.log){
	      
		lambda.tilde.node.log.densities <- lambda.tilde.density(lambda.tilde=lambda.tilde.nodes,y=y[i],alpha=alpha.t,log=TRUE)
		lambda.tilde.node.densities <- exp(lambda.tilde.node.log.densities)
		K <- max(lambda.tilde.node.log.densities)
		
		tmp.Finv <- qgamma(p=lambda.tilde.nodes,alpha,1)
		tmp.log.Finv <- log(tmp.Finv)
	    
		E.Finv[i] <- 0.5*exp(K)*sum(lambda.tilde.weights*tmp.Finv*exp(lambda.tilde.node.log.densities-K))
		E.log.Finv[i] <- 0.5*exp(K)*sum(lambda.tilde.weights*tmp.log.Finv*exp(lambda.tilde.node.log.densities-K))
		    
	      } else {
		      
		lambda.tilde.node.densities <- lambda.tilde.density(lambda.tilde=lambda.tilde.nodes,y=y[i],alpha=alpha.t,log=FALSE)
		      
		tmp.Finv <- qgamma(p=lambda.tilde.nodes,alpha,1)
		tmp.log.Finv <- log(tmp.Finv)
		    
		E.Finv[i] <- 0.5*sum(lambda.tilde.weights*tmp.Finv*lambda.tilde.node.densities)
		E.log.Finv[i] <- 0.5*sum(lambda.tilde.weights*tmp.log.Finv*lambda.tilde.node.densities)
		    
	      }
		      
	      if (verbose){
		cat(ppaste("======== Computing E-step for observation ",i," =============\n"))
		cat("tmp.Finv:\n") ; print(tmp.Finv)
		cat("tmp.log.Finv:\n") ; print(tmp.log.Finv)
		cat("lambda.tilde.node.densities:\n") ; print(lambda.tilde.node.densities)
		cat("lambda.tilde.weights:\n") ; print(lambda.tilde.weights)
		cat("=======================================================\n")
	      }
		      
	    }
		    
	    ## Finally, compute the Q-function:
	    ret <- sum(y*E.log.Finv - E.Finv)
		    
	    if (verbose){
		cat("============= Q_{AA}(alpha|alpha.t) =============\n")
		cat("alpha   = ",alpha,"\n")
		cat("alpha.t = ",alpha.t,"\n")
		cat("Q(alpha|alpha.t) = ",ret,"\n")
		cat("Details:\n")
		cat("y:\n") ; print(y)
		cat("lambda.tilde.nodes:\n") ; print(lambda.tilde.nodes)
		cat("lambda.tilde.weights:\n") ; print(lambda.tilde.weights)
		cat("E[F^{-1}]:\n") ; print(E.Finv)
		cat("E[log(F^{-1})]:\n") ; print(E.log.Finv)
		cat("=================================================\n\n")
	    }
		    
	    return(ret)
	}
		
	alpha.opt <- optim(par=alpha.start,fn=Q.func.gamma.hp.AA,method="L-BFGS-B",lower=eps,control=list(fnscale=-1),
			   y=y,alpha.t=alpha.t,lambda.tilde.nodes=lambda.tilde.nodes,
			   lambda.tilde.weights=lambda.tilde.weights,
			   verbose=verbose) # additional args to Q.func
			   
	if (alpha.opt$convergence != 0){
		warning("'theta' update did not converge in AA-update")
	}

	return(alpha.opt$par)
}

"gamma.hp.aa.em" <- function(y,groups,theta.0,em.tol=1e-6,em.tol.type="relative",n.MC=10000,n.nodes=100,n.int=1000,eps=1e-8,max.em.iter=1000,keep.paths=TRUE,print.every=1,verbose=TRUE)
{
	alpha.t  <- theta.0[1]
	u.levels <- unique(groups)
	J <- length(u.levels)
	y.groups <- vector("list",J)
	y.group.sums  <- rep(NA,J)
	y.group.sizes <- rep(NA,J)
	for (i in 1:J){
		i.tmp <- groups==u.levels[i]
		y.groups[[i]] <- y[i.tmp]
		y.group.sums[i]  <- sum(y[i.tmp])
		y.group.sizes[i] <- sum(i.tmp)
	}
	n <- sum(y.group.sizes)
	m <- length(y)
	
	# Find Gaussian-Quadrature nodes:
	gq.nodes <- gauss.quad(n=n.nodes,kind="legendre")
	lambda.tilde.nodes <- 0.5*gq.nodes$nodes+0.5
	lambda.tilde.weights <- gq.nodes$weights

	y.obs <- list("y.groups"=y.groups,"J"=J,"group.sizes"=y.group.sizes,"group.sums"=y.group.sums,"y"=y,"m"=m)
	fixed <- list("n.nodes"=n.nodes,"eps"=eps,
		      "lambda.tilde.nodes"=lambda.tilde.nodes,"lambda.tilde.weights"=lambda.tilde.weights)
	
	if (verbose){
		cat("y.obs:\n") ; print(y.obs)
		cat("fixed:\n") ; print(fixed)
	}

	ret <- EM(y.obs=y.obs,theta.0=theta.0,fixed=fixed,update=update.gamma.hp.aa.em,logLike=gamma.hp.logLike,max.iter=max.em.iter,
		  tol=em.tol,tol.type=em.tol.type,keep.paths=keep.paths,print.every=print.every,verbose=verbose)

	return(ret)
}



"gamma.hp.pxem" <- function(y,groups,theta.0,nr.tol=1e-4,em.tol=1e-6,em.tol.type="relative",nr.tol.type="relative",max.nr.iter=100,max.em.iter=1000,keep.paths=TRUE,print.every=1,verbose=TRUE)
{
	alpha.t  <- theta.0[1]
	
	u.levels <- unique(groups)
	J <- length(u.levels)
	n <- sum(y.group.sizes)
	
	y.obs <- list("group.sums"=y.group.sums,"group.sizes"=y.group.sizes,"n"=n,"y"=y,"m"=length(y))
	fixed <- list("nr.tol"=nr.tol,"nr.tol.type"=nr.tol.type,"max.nr.iter"=max.nr.iter)

	if (verbose){
		cat("y.obs:\n") ; print(y.obs)
		cat("fixed:\n") ; print(fixed)
	}

        # Called as :: theta.t1 <- update(theta.t,y.obs,fixed,verbose)

	"update.gamma.hp.pxem" <- function(theta,y.obs,fixed,verbose){

		alpha.nr.t <- theta[1]
		max.nr.iter <- fixed$max.nr.iter
		y <- y.obs$y
		m <- y.obs$m
		
		## Implement NR-update:
		for (nr.iter in 1:max.nr.iter){
		
		  E.log.lambda <- digamma(y+alpha.nr.t) - log(2*1)
		  beta.nr.t <- 1.0 # (sum(y)+m*alpha.nr.t)/(2*sum(E.log.lambda))
		  alpha.nr.t1 <- alpha.nr.t - ( log(beta.nr.t) - digamma(alpha.nr.t) + mean(E.log.lambda) )/(  - psigamma(alpha.nr.t) ) # + (m/(sum(y)+m*alpha.nr.t)) )
		  
		}
		
		return(alpha.nr.t1)
	}

	ret <- EM(y.obs=y.obs,theta.0=theta.0,fixed=fixed,update=update.gamma.hp.pxem,logLike=gamma.hp.logLike,max.iter=max.em.iter,
		  tol=em.tol,tol.type=em.tol.type,keep.paths=keep.paths,print.every=print.every,verbose=verbose)

	return(ret)
}

"gamma.hp.iem" <- function(y,groups,theta.0,iem.order,nr.tol=1e-4,em.tol=1e-6,em.tol.type="relative",nr.tol.type="relative",max.nr.iter=100,n.MC=10000,n.nodes=100,n.int=1000,eps=1e-8,max.em.iter=1000,keep.paths=TRUE,print.every=1,verbose=TRUE)

{
	alpha.t <- theta.0[1]
	
	u.levels <- unique(groups)
	J <- length(u.levels)
	y.groups <- vector("list",J)
	y.group.sums  <- rep(NA,J)
	y.group.sizes <- rep(NA,J)
	for (i in 1:J){
		i.tmp <- groups==u.levels[i]
		y.groups[[i]] <- y[i.tmp]
		y.group.sums[i]  <- sum(y[i.tmp])
		y.group.sizes[i] <- sum(i.tmp)
	}
	n <- sum(y.group.sizes)
	m <- length(y)
	
	# Find Gaussian-Quadrature nodes:
	gq.nodes <- gauss.quad(n=n.nodes,kind="legendre")
	lambda.tilde.nodes <- 0.5*gq.nodes$nodes+0.5
	lambda.tilde.weights <- gq.nodes$weights

	gq.nodes <- gauss.quad(n=n.nodes,kind="laguerre")
	lambda.nodes <- gq.nodes$nodes
	lambda.weights <- gq.nodes$weights

	##########################################
	brute.force.aasa <- TRUE
	if (brute.force.aasa){
	  n.nodes <- n.nodes*10
	  lambda.nodes <- seq(eps,2*max(y),length.out=n.nodes)
	  lambda.weights <- rep(diff(lambda.nodes)[1],times=n.nodes)
	}
	##########################################
	
	y.obs <- list("group.sums"=y.group.sums,"group.sizes"=y.group.sizes,"n"=n,"y.groups"=y.groups,"J"=J,"y"=y,"m"=m)
	fixed <- list("order"=iem.order,"nr.tol"=nr.tol,"nr.tol.type"=nr.tol.type,"max.nr.iter"=max.nr.iter,"n.MC"=n.MC,"n.int"=n.int,"eps"=eps,
		      "n.nodes"=n.nodes,"lambda.tilde.nodes"=lambda.tilde.nodes,"lambda.tilde.weights"=lambda.tilde.weights,
		      "lambda.nodes"=lambda.nodes,"lambda.weights"=lambda.weights)

	if (verbose){
		cat("y.obs:\n") ; print(y.obs)
		cat("fixed:\n") ; print(fixed)
	}

        # Called as :: theta.t1 <- update(theta.t,y.obs,fixed,verbose)

	"update.gamma.hp.iem" <- function(theta,y.obs,fixed,verbose){

		# Fixed components for AA-portion:
		n.MC <- fixed$n.MC
		n.int <- fixed$n.int
		lambda.tilde.nodes <- fixed$lambda.tilde.nodes
		lambda.tilde.weights <- fixed$lambda.tilde.weights
		lambda.nodes <- fixed$lambda.nodes
		lambda.weights <- fixed$lambda.weights
		eps <- fixed$eps

		# Fixed components for SA-portion:
		nr.tol <- fixed$nr.tol
		nr.tol.type <- fixed$nr.tol.type
		max.nr.iter <- fixed$max.nr.iter
		
		m <- y.obs$m
		alpha.t <- theta[1]
		
		if (fixed$order == "SA-AA"){
		
		  # (t + 0.5) update in AA-augmentation:
		  theta.t0.5 <- update.gamma.hp.aa.em(theta,y.obs,fixed,verbose)

		  if (verbose){
		    cat("theta.t0.5:\n") ; print(theta.t0.5)
		  }
		  
		  # (t + 1.0) update in interwoven-augmentation via Newton-Raphson:
		  alpha.nr.t <- theta.t0.5
		  alpha.t0.5 <- theta.t0.5
		  E.tilde.log.Finv <- rep(NA,m)
		  
		  for (i in 1:m){
		  
			lambda.tilde.node.log.densities <- lambda.tilde.density(lambda.tilde=lambda.tilde.nodes,y=y[i],alpha=alpha.t,log=TRUE)
			lambda.tilde.node.densities <- exp(lambda.tilde.node.log.densities)
			K <- max(lambda.tilde.node.log.densities)
			tmp.log.Finv <- log(qgamma(p=lambda.tilde.nodes,alpha.t0.5,1))
			E.tilde.log.Finv[i] <- 0.5*exp(K)*sum(lambda.tilde.weights*tmp.log.Finv*exp(lambda.tilde.node.log.densities-K))
		    
		  }
		  
		  for (nr.iter in 1:max.nr.iter){
			alpha.nr.t1 <- alpha.nr.t - (digamma(alpha.nr.t)-mean(E.tilde.log.Finv))/psigamma(alpha.nr.t)
		  }
		  
		  theta.t1 <- alpha.nr.t1

		} else if (fixed$order == "AA-SA"){
		
		  ###############################
		  ## TODO:                    ###
		  ## CURRENTLY NOT WORKING... ###
		  ###############################
		  
		  ## Need optim all of the way for this one...
		  
		  # (t + 0.5) update in SA-augmentation:
		  theta.t0.5 <- update.gamma.hp.sa.em(theta,y.obs,fixed,verbose)

		  if (verbose){
		    cat("theta.t0.5:\n") ; print(theta.t0.5)
		  }
		  
		  # (t + 1.0) update in interwoven-augmentation, needs optim:
		  alpha.start <- theta.t0.5
		  alpha.t0.5 <- theta.t0.5
		  
		  alpha.opt <- optim(par=alpha.start,fn=iem.aasa.gamma.hp.Qfunc,method="L-BFGS-B",lower=eps,control=list(fnscale=-1),
			   y=y,alpha.t=alpha.t,alpha.t0.5=alpha.t0.5,
			   lambda.nodes=lambda.nodes,lambda.weights=lambda.weights,
			   verbose=verbose) # additional args to Q.func
			   
		  if (alpha.opt$convergence != 0){
		    warning("'theta' update did not converge in AA-update")
		  }

		  theta.t1 <- alpha.opt$par
  
		} else {
			stop("Invalid order in interwoven EM: must be 'AA-SA' or 'SA-AA'")		
		}
		
		return(theta.t1)
	}

	ret <- EM(y.obs=y.obs,theta.0=theta.0,fixed=fixed,update=update.gamma.hp.iem,logLike=gamma.hp.logLike,max.iter=max.em.iter,
		  tol=em.tol,tol.type=em.tol.type,keep.paths=keep.paths,print.every=print.every,verbose=verbose)

	return(ret)
}

"lambda.density" <- function(lambda,y,alpha,log=FALSE)
{
    ## Vectorized wrt lambda, not y, alpha
    return(dgamma(x=lambda,y+alpha,2,log=log))
}

"iem.aasa.gamma.hp.Qfunc" <- function(alpha,alpha.t,alpha.t0.5,y,lambda.nodes,lambda.weights,verbose)
{
    ###############################
    ## TODO:                    ###
    ## CURRENTLY NOT WORKING... ###
    ###############################
  
    m <- length(y)
    E.log.F.inv.F <- rep(NA,m)
    E.F.inv.F <- rep(NA,m)
    
    if (verbose){
	cat("=========================================\n")
	cat(ppaste("alpha      = ",alpha,"\n"))
	cat(ppaste("alpha.t    = ",alpha.t,"\n"))
	cat(ppaste("alpha.t0.5 = ",alpha.t0.5,"\n"))
	cat("lambda.nodes:\n") ; print(lambda.nodes)
	cat("lambda.weights:\n") ; print(lambda.weights)
	cat("=========================================\n")
    }
    
    for (i in 1:m){
    
	lambda.node.log.densities <- lambda.density(lambda=lambda.nodes,y=y[i],alpha=alpha.t,log=TRUE)
	lambda.node.densities <- exp(lambda.node.log.densities)
	K <- max(lambda.node.log.densities,na.rm=TRUE)

	## TODO: Very unstable... try to improve...
	tmp.F <- pgamma(q=lambda.nodes,alpha.t0.5,1,log.p=TRUE)
	tmp.Finv.F <- qgamma(p=tmp.F,alpha,1,log.p=TRUE)
	log.tmp.Finv.F <- log(tmp.Finv.F)
	
	E.F.inv.F[i] <- exp(K)*sum(lambda.weights*tmp.Finv.F*exp(lambda.node.log.densities-K))
	E.log.F.inv.F[i] <- exp(K)*sum(lambda.weights*log.tmp.Finv.F*exp(lambda.node.log.densities-K))
    
    }

    ret <- sum(y*E.log.F.inv.F - E.F.inv.F)
    

    if (verbose){
	cat("=========================================\n")
	cat("E.F.inv.F:\n") ; print(E.F.inv.F)
	cat("E.log.Finv.F:\n") ; print(E.log.F.inv.F)
	cat(ppaste("Q = ",ret,"\n"))
	cat("=========================================\n")
    }
    
    return(ret)
}

"gamma.hp.aem" <- function(y,groups,theta.0,aem.order,nr.tol=1e-4,em.tol=1e-6,em.tol.type="relative",nr.tol.type="relative",max.nr.iter=100,n.MC=10000,n.nodes=100,n.int=1000,eps=1e-8,max.em.iter=1000,keep.paths=TRUE,print.every=1,verbose=TRUE)

{
	alpha.t <- theta.0[1]
	
	u.levels <- unique(groups)
	J <- length(u.levels)
	y.groups <- vector("list",J)
	y.group.sums  <- rep(NA,J)
	y.group.sizes <- rep(NA,J)
	for (i in 1:J){
		i.tmp <- groups==u.levels[i]
		y.groups[[i]] <- y[i.tmp]
		y.group.sums[i]  <- sum(y[i.tmp])
		y.group.sizes[i] <- sum(i.tmp)
	}
	n <- sum(y.group.sizes)
	m <- length(y)
	
	# Find Gaussian-Quadrature nodes:
	gq.nodes <- gauss.quad(n=n.nodes,kind="legendre")
	lambda.tilde.nodes <- 0.5*gq.nodes$nodes+0.5
	lambda.tilde.weights <- gq.nodes$weights
	
	y.obs <- list("group.sums"=y.group.sums,"group.sizes"=y.group.sizes,"n"=n,"y.groups"=y.groups,"J"=J,"y"=y,"m"=m)
	fixed <- list("order"=aem.order,"nr.tol"=nr.tol,"nr.tol.type"=nr.tol.type,"max.nr.iter"=max.nr.iter,"n.MC"=n.MC,"n.int"=n.int,"eps"=eps,
		      "n.nodes"=n.nodes,"lambda.tilde.nodes"=lambda.tilde.nodes,"lambda.tilde.weights"=lambda.tilde.weights)

	if (verbose){
		cat("y.obs:\n") ; print(y.obs)
		cat("fixed:\n") ; print(fixed)
	}

        # Called as :: theta.t1 <- update(theta.t,y.obs,fixed,verbose)

	"update.gamma.hp.aem" <- function(theta,y.obs,fixed,verbose){

		if (fixed$order == "SA-AA"){

			# (t + 0.5) update in AA-augmentation:
			theta.t0.5 <- update.gamma.hp.sa.em(theta,y.obs,fixed,verbose)

			# (t + 1.0) update in SA-augmentation:
			theta.t1 <- update.gamma.hp.aa.em(theta.t0.5,y.obs,fixed,verbose)

		} else if (fixed$order == "AA-SA"){

			# (t + 0.5) update in AA-augmentation:
			theta.t0.5 <- update.gamma.hp.aa.em(theta,y.obs,fixed,verbose)

			# (t + 1.0) update in SA-augmentation:
			theta.t1 <- update.gamma.hp.sa.em(theta.t0.5,y.obs,fixed,verbose)

		} else {
			stop("Invalid order in alternating EM: must be 'AA-SA' or 'SA-AA'")
		}

		return(theta.t1)
	}


	ret <- EM(y.obs=y.obs,theta.0=theta.0,fixed=fixed,update=update.gamma.hp.aem,logLike=gamma.hp.logLike,max.iter=max.em.iter,
		  tol=em.tol,tol.type=em.tol.type,keep.paths=keep.paths,print.every=print.every,verbose=verbose)

	return(ret)

}
